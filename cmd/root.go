// Copyright (c) 2020 Kevin L. Mitchell
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License.  You
// may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.  See the License for the specific language governing
// permissions and limitations under the License.

package cmd

import (
	"fmt"
	"io"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/klmitch/overcover/coverage"
)

// Variables used to store the values of flags.
var (
	config string
)

// Variables used for mocking for the tests.
var (
	stdout         io.Writer            = os.Stdout
	stderr         io.Writer            = os.Stderr
	exit           func(int)            = os.Exit
	getString      func(string) string  = viper.GetString
	getFloat64     func(string) float64 = viper.GetFloat64
	setConfigFile  func(string)         = viper.SetConfigFile
	readInConfig   func() error         = viper.ReadInConfig
	configFileUsed func() string        = viper.ConfigFileUsed
)

// rootCmd describes the overcover command to cobra.
var rootCmd = &cobra.Command{
	Use:   "overcover",
	Short: "Golang overall coverage tool with threshold enforcement",
	Long:  `A tool for reporting and testing the overall test suite coverage of a test suite written in go.  This parses the coverage profile output file (generated by passing a filename to the "-coverprofile" option of "go test") and reports the overall coverage of the test suite.  It can also test that the coverage meets a certain minimum threshold.`,
	Run: func(cmd *cobra.Command, args []string) {
		// Load the coverage; this reads the coverage profile
		// and sums the statement counts
		coverprofile := getString("coverprofile")
		if coverprofile == "" {
			fmt.Fprintf(stderr, "No coverage profile file specified!  Use -p or provide a configuration file.\n")
			cmd.Usage()
			exit(2)
		}
		file, err := os.Open(coverprofile)
		if err != nil {
			fmt.Fprintf(stderr, "Unable to open coverage profile file: %s\n", err)
			exit(2)
		}
		defer file.Close()
		cov, err := coverage.LoadCoverage(file)
		if err != nil {
			fmt.Fprintf(stderr, "Unable to read coverage profile file: %s\n", err)
			exit(3)
		}

		// Compute the overall coverage and emit it
		coverage := float64(cov.Executed) / float64(cov.Total) * 100.0
		fmt.Fprintf(stdout, "%d statements out of %d covered; overall coverage: %.1f%%\n", cov.Executed, cov.Total, coverage)

		// Verify that we met the threshold
		threshold := getFloat64("threshold")
		if threshold > 0.0 && coverage < threshold {
			fmt.Fprintf(stderr, "\nFailed to meet coverage threshold of %.1f%%\n", threshold)
			exit(1)
		}
	},
}

// Execute is the entrypoint for overcover.  This invokes the root
// command, which performs all the work.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(stderr, err)
		exit(4)
	}
}

// init initializes the flags for overcover.
func init() {
	// Initialize cobra and viper
	cobra.OnInitialize(readConfig)
	viper.SetEnvPrefix("overcover")

	// Set up the flags
	rootCmd.Flags().StringVarP(&config, "config", "c", os.Getenv("OVERCOVER_CONFIG"), "Configuration file to read.  All command line options may be set through the configuration file.")
	rootCmd.Flags().Float64P("threshold", "t", 0, "Set the minimum threshold for coverage; coverage below this threshold will result in an error.")
	rootCmd.Flags().StringP("coverprofile", "p", "", "Specify the coverage profile file to read.")

	// Bind them to viper
	viper.BindPFlag("threshold", rootCmd.Flags().Lookup("threshold"))
	viper.BindEnv("threshold")
	viper.BindPFlag("coverprofile", rootCmd.Flags().Lookup("coverprofile"))
	viper.BindEnv("coverprofile")
}

// readConfig reads the configuration file using Viper.
func readConfig() {
	// Is a configuration file set?
	if config == "" {
		return
	}

	// Select it
	setConfigFile(config)

	// Read the configuration
	if err := readInConfig(); err == nil {
		fmt.Fprintf(stdout, "Using configuration file %s\n", configFileUsed())
	}
}
