// Copyright (c) 2020 Kevin L. Mitchell
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License.  You
// may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.  See the License for the specific language governing
// permissions and limitations under the License.

package cmd

import (
	"fmt"
	"io"
	"math"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/klmitch/overcover/coverage"
)

// Variables used to store the values of flags.
var (
	config   string
	readOnly bool
)

// Variables used for mocking for the tests.
var (
	stdout         io.Writer                 = os.Stdout
	stderr         io.Writer                 = os.Stderr
	exit           func(int)                 = os.Exit
	getString      func(string) string       = viper.GetString
	getFloat64     func(string) float64      = viper.GetFloat64
	setConfigFile  func(string)              = viper.SetConfigFile
	readInConfig   func() error              = viper.ReadInConfig
	configFileUsed func() string             = viper.ConfigFileUsed
	setConfig      func(string, interface{}) = viper.Set
	writeConfig    func(string) error        = viper.WriteConfigAs
)

// rootCmd describes the overcover command to cobra.
var rootCmd = &cobra.Command{
	Use:   "overcover",
	Short: "Golang overall coverage tool with threshold enforcement",
	Long:  `A tool for reporting and testing the overall test suite coverage of a test suite written in go.  This parses the coverage profile output file (generated by passing a filename to the "-coverprofile" option of "go test") and reports the overall coverage of the test suite.  It can also test that the coverage meets a certain minimum threshold.`,
	Run: func(cmd *cobra.Command, args []string) {
		// Load the coverage; this reads the coverage profile
		// and sums the statement counts
		coverprofile := getString("coverprofile")
		if coverprofile == "" {
			fmt.Fprintf(stderr, "No coverage profile file specified!  Use -p or provide a configuration file.\n")
			cmd.Usage()
			exit(2)
		}
		file, err := os.Open(coverprofile)
		if err != nil {
			fmt.Fprintf(stderr, "Unable to open coverage profile file: %s\n", err)
			exit(2)
		}
		defer file.Close()
		cov, err := coverage.LoadCoverage(file)
		if err != nil {
			fmt.Fprintf(stderr, "Unable to read coverage profile file: %s\n", err)
			exit(3)
		}

		// Compute the overall coverage and emit it
		coverage := float64(cov.Executed) / float64(cov.Total) * 100.0
		fmt.Fprintf(stdout, "%d statements out of %d covered; overall coverage: %.1f%%\n", cov.Executed, cov.Total, coverage)

		// Verify that we met the threshold
		threshold := getFloat64("threshold")
		if threshold > 0.0 && coverage < threshold {
			fmt.Fprintf(stderr, "\nFailed to meet coverage threshold of %.1f%%\n", threshold)
			exit(1)
		}

		// OK, now let's see if the threshold needs updating
		minHeadroom := getFloat64("min_headroom")
		maxHeadroom := getFloat64("max_headroom")
		if config != "" && minHeadroom >= 0.0 && maxHeadroom > minHeadroom && coverage > threshold+maxHeadroom {
			// Compute new threshold
			newThreshold := math.Round(coverage*10.0)/10.0 - minHeadroom

			// If we're read-only, generate an error
			if readOnly {
				fmt.Fprintf(stderr, "\nCoverage exceeds maximum headroom.  Update threshold to %.1f%%\n", newThreshold)
				exit(5)
			}

			// OK, update the configuration
			fmt.Fprintf(stdout, "Updating configuration file %s with new threshold value %.1f%%\n", config, newThreshold)
			setConfig("threshold", newThreshold)
			if err := writeConfig(config); err != nil {
				fmt.Fprintf(stderr, "\nFailed to write updated config with new threshold %.1f%% to %s: %s\n", newThreshold, config, err)
				exit(5)
			}
		}
	},
}

// Execute is the entrypoint for overcover.  This invokes the root
// command, which performs all the work.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(stderr, err)
		exit(4)
	}
}

// init initializes the flags for overcover.
func init() {
	// Initialize cobra and viper
	cobra.OnInitialize(readConfig)
	viper.SetEnvPrefix("overcover")

	// Set up the flags
	rootCmd.Flags().StringVarP(&config, "config", "c", os.Getenv("OVERCOVER_CONFIG"), "Configuration file to read.  All command line options may be set through the configuration file.")
	_, readOnlyDefault := os.LookupEnv("OVERCOVER_READONLY")
	rootCmd.Flags().BoolVarP(&readOnly, "readonly", "r", readOnlyDefault, "Used to indicate that the configuration file should only be read, not written.")
	rootCmd.Flags().Float64P("threshold", "t", 0, "Set the minimum threshold for coverage; coverage below this threshold will result in an error.")
	rootCmd.Flags().StringP("coverprofile", "p", "", "Specify the coverage profile file to read.")
	rootCmd.Flags().Float64P("min-headroom", "m", 0, "Set the minimum headroom.  If the threshold is raised, it will be raised to the current coverage minus this value.")
	rootCmd.Flags().Float64P("max-headroom", "M", 0, "Set the maximum headroom.  If the coverage is more than the threshold plus this value, the threshold will be raised.")

	// Bind them to viper
	viper.BindPFlag("threshold", rootCmd.Flags().Lookup("threshold"))
	viper.BindEnv("threshold")
	viper.BindPFlag("coverprofile", rootCmd.Flags().Lookup("coverprofile"))
	viper.BindEnv("coverprofile")
	viper.BindPFlag("min_headroom", rootCmd.Flags().Lookup("min-headroom"))
	viper.BindEnv("min_headroom")
	viper.BindPFlag("max_headroom", rootCmd.Flags().Lookup("max-headroom"))
	viper.BindEnv("max_headroom")
}

// readConfig reads the configuration file using Viper.
func readConfig() {
	// Is a configuration file set?
	if config == "" {
		return
	}

	// Select it
	setConfigFile(config)

	// Read the configuration
	if err := readInConfig(); err == nil {
		fmt.Fprintf(stdout, "Using configuration file %s\n", configFileUsed())
	}
}
